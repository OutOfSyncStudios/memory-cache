declare module "@outofsync/MemoryCache";

type AnyOrNull = any | null;
type NumOrNull = number | null;

export declare class MemoryCacheError extends Error {
  constructor(error: Error | string);
};

interface MemoryCacheOptions {
  debug: boolean;
  bypassUnsupported: boolean;
};

declare class MemoryCache extends Event {
  constructor(options?: MemoryCacheOptions);

  // Connection
  createClient(): MemoryCache;
  quit(): MemoryCache;
  end(): MemoryCache;
  auth(password: string, callback: function): string;
  echo(message: string, callback: function): string;
  ping(message: string, callback: function): string;
  swapdb(dbIndex1: number, dbIndex2: number, callback: function): string;
  select(dbIndex: number, callback: function): string;

  // Cluster
  cluster(...params?: any, callback: function): void;
  readonly(callback: function): void;
  readwrite(callback: function): void;

  // Geo
  geoadd(key: string, ...params?: any, callback: function): NumOrNull;
  geodist(key: string, member1: number, member2: number, ...params?: any, callback: function): string | null;
  geohash(key: string, ...members?: any, callback: function): string[];
  geopos(key: string, ...members?: any, callback: function): array<any>;
  georadius(...members?: any, callback: function): void;
  georadiusbymember(...members?: any, callback: function): void;

  // Hash Maps
  hdel(key: string, ...fields?: string, callback: function): number;
  hexists(key: string, field: string, callback: function): number;
  hget(key: string, field: string, callback: function): AnyOrNull;
  hgetall(key: string, callback: function): any;
  hincrby(key: string, field: string, value: number, callback: function): number;
  hincrbyfloat(key: string, field: string, value: number, callback: function): number;
  hkeys(key: string, callback: function): string[];
  hlen(key: string, callback: function): number;
  hmget(key: string, ...fields?: string, callback: function): string[];
  hmset(key: string, ...params?: any, callback: function): string;
  hscan(key: string, cursor: any, pattern: any, count: number, callback: function): void;
  hset(key: string, field: string, value: any, callback: function): number;
  hsetnx(key: string, field: string, value: any, callback: function): number;
  hstrlen(key: string, field: string, callback: function): number;
  hvals(key: string, callback: function): string[];

  // HyperLogLog (Unique Lists)
  pfadd(key: string, ...elements?: any, callback: function): void;
  pfcount(...keys?: string, callback: function): void;
  pfmerge(destkey: string, ...srckeys?: sting, callback: function): void;

  // Key
  del(...keys: string, callback: function): number;
  dump(key: string, callback: function): string;
  exists(...keys?: string, callback: function): number;
  expire(key: string, seconds: number, callback: function): number;
  expireat(key: string, timestamp: number, callback: function): number;
  keys(pattern: string, callback: function): string[];
  migrate(...params?: any, callback: function): void;
  move(key: string, dbIndex: number, callback: function): number;
  object(subcommand: string, ...params?: any, callback: function): void;
  persist(key: string, callback: function): number;
  pexpire(key: string, millisecond: number, callback: function): number;
  pexpireat(key: string, timestamp: number, callback: function): number;
  pttl(key: string, callback: function): number;
  randomkey(callback): string;
  rename(key: string, newkey: string, callback: function): string;
  renamenx(key: string, newkey: string, callback: function): string;
  restore(key: string, ttl: number, value: any, replace: boolean, callback: function): string;
  scan(cursor: any, pattern: string, count: number, callback: function): void;
  sort(key: string, ...params?: any, callback: function): void;
  touch(...keys?: string, callback: function): number;
  ttl(key: string, callback: functions): number;
  type(key: string, callback: function): string;
  unlink(...keys?: string, callback: function): number;
  wait(numslaves: number, timeout: number, callback: function): void;

  // Lists (Array / Queue / Stack)
  blpop(...params?: any, callback: function): void
  bepop(...params?: any, callback: function): void
  bepoplpush(...params?: any, callback: function): void

  lindex(key: string, index: number, callback: function): AnyOrNull;
  linsert(key: string, before?: boolean | string, pivot: number, value: any, callback: function): number;
  llen(key: string, callback: function): number;
  lpop(key: string, callback: function): AnyOrNull;
  lpush(key: string, value: any, callback: function): number;
  lpushx(key: string, value: any, callback: function): number;
  lrange(key: string, start: number, stop: number, callback: function): array<any>;
  lrem(key: string, count: number, value: any, callback: function): number;
  lset(key: string, index: number, value: any, callback: function): string;
  ltrim(key: string, start: number, stop: number, callback: function): array<any>;

  rpop(key: string, callback: function): AnyOrNull;
  rpoplpush(sourcekey: string, destkey: string, callback: function): AnyOrNull;
  rpush(key: string, value: any, callback: function): number;
  rpushx(key: string, value: any, callback: function): number;

  // Pub/Sub
  psubscribe(...params?: any, callback: function): void;
  pubsub(...params?: any, callback: function): void;
  publish(...params?: any, callback: function): void;
  punsubscribe(...params?: any, callback: function): void;
  subscribe(...params?: any, callback: function): void;
  unsubscribe(...params?: any, callback: function): void;

  // Scripting
  eval(...params?: any, callback: function): void;
  evalsha(...params?: any, callback: function): void;
  script(...params?: any, callback: function): void;

  // Server
  bgrewriteaof(callback: function): void;
  bgsave(callback: function): string;
  client(...params?: any, callback: function): void;
  command(...params?: any, callback: function): void;
  config(...params?: any, callback: function): void;
  dbsize(callback: function): number;
  debug(command: string, ...params?: any, callback: function): void;
  flushall(...params?: any, callback: function): string;
  flushdb(callback: function): string;
  info(section: any, callback: function): string;
  lastsave(callback: function): number;
  monitor(callback: function): void;
  role(callback: function): array<any>;
  save(callback: function): string;
  shutdown(callback: function): void;
  slaveof(host: string, port: number): void;
  slowlog(command: string, param: any): void;
  sync(callback: function): void;
  time(callback: function): number;

  // Sets
  sadd(key: string, ...members?: any, callback: function): number;
  scard(key: string, callback: function): number;
  sdiff(key: string, ...keys?: string, callback: function): number;
  sdiffstore(destkey: string, key: string, ...keys: string, callback: function): number;
  sinter(key: string, ...keys: string, callback: function): number;
  sinterstore(destkey: string, key: string, ...keys: string, callback: function): number;
  sismember(key: string, member: string, callback: function): number;
  smembers(key: string, callback: function): string[];
  smove(sourcekey: string, destkey: string, member: string, callback): number;
  spop(key: string, count: number, callback: function): string[];
  srandmember(key: string, count: number, callback: function): string[];
  srem(key: string, ...members: string, callback: function): number;
  sscan(...params?: any, callback: function): void;
  sunion(key: string,...keys: string, callback: function): number;
  sunionstore(destkey: string, key: string, ...keys: string, callback: function): number;

  // Sorted Sets
  zadd(key: string, ...params: any, callback: function): number;
  zcard(key: string, callback: function): number;
  zcount(key: string, min: string, max: string, callback: function): number;
  zincrby(key: string, increment: number, member: string, callback: function): number;
  zinterstore(...params: any, callback: function): void;
  zlexcount(key: string, min: string, max: string, callback: function): number;
  zrange(key: string, start: number, stop: number, ...params: any, callback: function): string[];
  zrangebylex(key: string, min: number, max: number, ...params: any, callback: function): string[];
  zrangebyscore(key: string, min: number, max: number, ...params: any, callback: function): string[];
  zrank(key: string, member: number, callback: function): NumOrNull;
  zrem(key: string, ...members: string, callback: function): number;
  zremrangebylex(key: string, min: string, max: string, callback: function): number;
  zremrangebyrank(key: string, start: number, stop: number, callback: function): number;
  zremrangebyscore(key: string, min: number, max: number, callback: function): number;
  zrevrange(key: string, start: number, stop: number, ...params: any, callback: function): string[];
  zrevrangebylex(key: string, max: string, min: string, ...params: any, callback: function): string[];
  zrevrangebyscore(key: string, member: string, callback: function): string[];
  zrevrank(key: string, member: string, callback: function): NumOrNull;
  zscore(key: string, member: string, callback: function): string;
  zunionstore(...params: any, callback: function): void;
  zscan(...params: any, callback: function): void;

  // Strings
  append(key: string, value: string, callback: function): number;
  bitcount(key: string, ...params: any, callback: function): number;
  bitfield(...params: any, callback: function): void;
  bitop(operation: string, destkey: string, ...srckeys: string, callback: function): number;
  bitpos(key: string, bit: number, start: number, end: number, callback: function): void;
  decr(key: string, callback: function): number;
  decrby(key: string, amount: number, callback: function): number;
  get(key: string, callback: function): string;
  getbit(key: string, offset: number, callback: function): number;
  getrange(key: string, start: number, end: number, callback: function): string;
  getset(key: string, value: string, callback: function): string;
  incr(key: string, callback: function): number;
  incrby(key: string, amount: number, callback: function): number;
  incrbyfloat(key: string, amount: number, callback: function): number;
  mget(...keys: string, callback: function): string[];
  mset(...params: string, callback: function): number;
  msetnx(...params: string, callback: function): number;
  psetex(key: string, pttl: number, value: string, callback: function): string;
  set(key: string, value: string, ...params: any, callback: function): string;
  setbit(key: string, offset: number, value: number, callback: function): number;
  setex(key: string, ttl: number, value: string, callback: function): number;
  setnx(key: string, value: string, callback: function): number;
  setrange(key: string, offset: number, value: string, callback: function): number;
  strlen(key: string, callback: function): number;

  // Transactions
  discard(callback: function, silent: boolean): string;
  exec(callback: function): string;
  multi(callback: function): string;
  unwatch(callback: function): void;
  watch(callback: function): void;

  // Async
  createClientAsync(): Promise<MemoryCache>;
  quitAsync(): Promise<MemoryCache>;
  endAsync(): Promise<MemoryCache>;
  authAsync(password: string, callback: function): Promise<string>;
  echoAsync(message: string, callback: function): Promise<string>;
  pingAsync(message: string, callback: function): Promise<string>;
  swapdbAsync(dbIndex1: number, dbIndex2: number, callback: function): Promise<string>;
  selectAsync(dbIndex: number, callback: function): Promise<string>;
  clusterAsync(...params?: any, callback: function): Promise<void>;
  readonlyAsync(callback: function): Promise<void>;
  readwriteAsync(callback: function): Promise<void>;
  geoaddAsync(key: string, ...params?: any, callback: function): Promise<NumOrNull>;
  geodistAsync(key: string, member1: number, member2: number, ...params?: any, callback: function): Promise<string | null>;
  geohashAsync(key: string, ...members?: any, callback: function): Promise<string[]>;
  geoposAsync(key: string, ...members?: any, callback: function): Promise<array<any>>;
  georadiusAsync(...members?: any, callback: function): Promise<void>;
  georadiusbymemberAsync(...members?: any, callback: function): Promise<void>;
  hdelAsync(key: string, ...fields?: string, callback: function): Promise<number>;
  hexistsAsync(key: string, field: string, callback: function): Promise<number>;
  hgetAsync(key: string, field: string, callback: function): Promise<AnyOrNull>;
  hgetallAsync(key: string, callback: function): Promise<any>;
  hincrbyAsync(key: string, field: string, value: number, callback: function): Promise<number>;
  hincrbyfloatAsync(key: string, field: string, value: number, callback: function): Promise<number>;
  hkeysAsync(key: string, callback: function): Promise<string[]>;
  hlenAsync(key: string, callback: function): Promise<number>;
  hmgetAsync(key: string, ...fields?: string, callback: function): Promise<string[]>;
  hmsetAsync(key: string, ...params?: any, callback: function): Promise<string>;
  hscanAsync(key: string, cursor: any, pattern: any, count: number, callback: function): Promise<void>;
  hsetAsync(key: string, field: string, value: any, callback: function): Promise<number>;
  hsetnxAsync(key: string, field: string, value: any, callback: function): Promise<number>;
  hstrlenAsync(key: string, field: string, callback: function): Promise<number>;
  hvalsAsync(key: string, callback: function): Promise<string[]>;
  pfaddAsync(key: string, ...elements?: any, callback: function): Promise<void>;
  pfcountAsync(...keys?: string, callback: function): Promise<void>;
  pfmergeAsync(destkey: string, ...srckeys?: sting, callback: function): Promise<void>;
  delAsync(...keys: string, callback: function): Promise<number>;
  dumpAsync(key: string, callback: function): Promise<string>;
  existsAsync(...keys?: string, callback: function): Promise<number>;
  expireAsync(key: string, seconds: number, callback: function): Promise<number>;
  expireatAsync(key: string, timestamp: number, callback: function): Promise<number>;
  keysAsync(pattern: string, callback: function): Promise<string[]>;
  migrateAsync(...params?: any, callback: function): Promise<void>;
  moveAsync(key: string, dbIndex: number, callback: function): Promise<number>;
  objectAsync(subcommand: string, ...params?: any, callback: function): Promise<void>;
  persistAsync(key: string, callback: function): Promise<number>;
  pexpireAsync(key: string, millisecond: number, callback: function): Promise<number>;
  pexpireatAsync(key: string, timestamp: number, callback: function): Promise<number>;
  pttlAsync(key: string, callback: function): Promise<number>;
  randomkeyAsync(callback): Promise<string>;
  renameAsync(key: string, newkey: string, callback: function): Promise<string>;
  renamenxAsync(key: string, newkey: string, callback: function): Promise<string>;
  restoreAsync(key: string, ttl: number, value: any, replace: boolean, callback: function): Promise<string>;
  scanAsync(cursor: any, pattern: string, count: number, callback: function): Promise<void>;
  sortAsync(key: string, ...params?: any, callback: function): Promise<void>;
  touchAsync(...keys?: string, callback: function): Promise<number>;
  ttlAsync(key: string, callback: functions): Promise<number>;
  typeAsync(key: string, callback: function): Promise<string>;
  unlinkAsync(...keys?: string, callback: function): Promise<number>;
  waitAsync(numslaves: number, timeout: number, callback: function): Promise<void>;
  blpopAsync(...params?: any, callback: function): Promise<void>;
  bepopAsync(...params?: any, callback: function): Promise<void>;
  bepoplpushAsync(...params?: any, callback: function): Promise<void>;
  lindexAsync(key: string, index: number, callback: function): Promise<AnyOrNull>;
  linsertAsync(key: string, before?: boolean | string, pivot: number, value: any, callback: function): Promise<number>;
  llenAsync(key: string, callback: function): Promise<number>;
  lpopAsync(key: string, callback: function): Promise<AnyOrNull>;
  lpushAsync(key: string, value: any, callback: function): Promise<number>;
  lpushxAsync(key: string, value: any, callback: function): Promise<number>;
  lrangeAsync(key: string, start: number, stop: number, callback: function): Promise<array<any>>;
  lremAsync(key: string, count: number, value: any, callback: function): Promise<number>;
  lsetAsync(key: string, index: number, value: any, callback: function): Promise<string>;
  ltrimAsync(key: string, start: number, stop: number, callback: function): Promise<array<any>>;
  rpopAsync(key: string, callback: function): Promise<AnyOrNull>;
  rpoplpushAsync(sourcekey: string, destkey: string, callback: function): Promise<AnyOrNull>;
  rpushAsync(key: string, value: any, callback: function): Promise<number>;
  rpushxAsync(key: string, value: any, callback: function): Promise<number>;
  psubscribeAsync(...params?: any, callback: function): Promise<void>;
  pubsubAsync(...params?: any, callback: function): Promise<void>;
  publishAsync(...params?: any, callback: function): Promise<void>;
  punsubscribeAsync(...params?: any, callback: function): Promise<void>;
  subscribeAsync(...params?: any, callback: function): Promise<void>;
  unsubscribeAsync(...params?: any, callback: function): Promise<void>;
  evalAsync(...params?: any, callback: function): Promise<void>;
  evalshaAsync(...params?: any, callback: function): Promise<void>;
  scriptAsync(...params?: any, callback: function): Promise<void>;
  bgrewriteaofAsync(callback: function): Promise<void>;
  bgsaveAsync(callback: function): Promise<string>;
  clientAsync(...params?: any, callback: function): Promise<void>;
  commandAsync(...params?: any, callback: function): Promise<void>;
  configAsync(...params?: any, callback: function): Promise<void>;
  dbsizeAsync(callback: function): Promise<number>;
  debugAsync(command: string, ...params?: any, callback: function): Promise<void>;
  flushallAsync(...params?: any, callback: function): Promise<string>;
  flushdbAsync(callback: function): Promise<string>;
  infoAsync(section: any, callback: function): Promise<string>;
  lastsaveAsync(callback: function): Promise<number>;
  monitorAsync(callback: function): Promise<void>;
  roleAsync(callback: function): Promise<array<any>>;
  saveAsync(callback: function): Promise<string>;
  shutdownAsync(callback: function): Promise<void>;
  slaveofAsync(host: string, port: number): Promise<void>;
  slowlogAsync(command: string, param: any): Promise<void>;
  syncAsync(callback: function): Promise<void>;
  timeAsync(callback: function): Promise<number>;
  saddAsync(key: string, ...members?: any, callback: function): Promise<number>;
  scardAsync(key: string, callback: function): Promise<number>;
  sdiffAsync(key: string, ...keys?: string, callback: function): Promise<number>;
  sdiffstoreAsync(destkey: string, key: string, ...keys: string, callback: function): Promise<number>;
  sinterAsync(key: string, ...keys: string, callback: function): Promise<number>;
  sinterstoreAsync(destkey: string, key: string, ...keys: string, callback: function): Promise<number>;
  sismemberAsync(key: string, member: string, callback: function): Promise<number>;
  smembersAsync(key: string, callback: function): Promise<string[]>;
  smoveAsync(sourcekey: string, destkey: string, member: string, callback): Promise<number>;
  spopAsync(key: string, count: number, callback: function): Promise<string[]>;
  srandmemberAsync(key: string, count: number, callback: function): Promise<string[]>;
  sremAsync(key: string, ...members: string, callback: function): Promise<number>;
  sscanAsync(...params?: any, callback: function): Promise<void>;
  sunionAsync(key: string,...keys: string, callback: function): Promise<number>;
  sunionstoreAsync(destkey: string, key: string, ...keys: string, callback: function): Promise<number>;
  zaddAsync(key: string, ...params: any, callback: function): Promise<number>;
  zcardAsync(key: string, callback: function): Promise<number>;
  zcountAsync(key: string, min: string, max: string, callback: function): Promise<number>;
  zincrbyAsync(key: string, increment: number, member: string, callback: function): Promise<number>;
  zinterstoreAsync(...params: any, callback: function): Promise<void>;
  zlexcountAsync(key: string, min: string, max: string, callback: function): Promise<number>;
  zrangeAsync(key: string, start: number, stop: number, ...params: any, callback: function): Promise<string[]>;
  zrangebylexAsync(key: string, min: number, max: number, ...params: any, callback: function): Promise<string[]>;
  zrangebyscoreAsync(key: string, min: number, max: number, ...params: any, callback: function): Promise<string[]>;
  zrankAsync(key: string, member: number, callback: function): Promise<NumOrNull>;
  zremAsync(key: string, ...members: string, callback: function): Promise<number>;
  zremrangebylexAsync(key: string, min: string, max: string, callback: function): Promise<number>;
  zremrangebyrankAsync(key: string, start: number, stop: number, callback: function): Promise<number>;
  zremrangebyscoreAsync(key: string, min: number, max: number, callback: function): Promise<number>;
  zrevrangeAsync(key: string, start: number, stop: number, ...params: any, callback: function): Promise<string[]>;
  zrevrangebylexAsync(key: string, max: string, min: string, ...params: any, callback: function): Promise<string[]>;
  zrevrangebyscoreAsync(key: string, member: string, callback: function): Promise<string[]>;
  zrevrankAsync(key: string, member: string, callback: function): Promise<NumOrNull>;
  zscoreAsync(key: string, member: string, callback: function): Promise<string>;
  zunionstoreAsync(...params: any, callback: function): Promise<void>;
  zscanAsync(...params: any, callback: function): Promise<void>;
  appendAsync(key: string, value: string, callback: function): Promise<number>;
  bitcountAsync(key: string, ...params: any, callback: function): Promise<number>;
  bitfieldAsync(...params: any, callback: function): Promise<void>;
  bitopAsync(operation: string, destkey: string, ...srckeys: string, callback: function): Promise<number>;
  bitposAsync(key: string, bit: number, start: number, end: number, callback: function): Promise<void>;
  decrAsync(key: string, callback: function): Promise<number>;
  decrbyAsync(key: string, amount: number, callback: function): Promise<number>;
  getAsync(key: string, callback: function): Promise<string>;
  getbitAsync(key: string, offset: number, callback: function): Promise<number>;
  getrangeAsync(key: string, start: number, end: number, callback: function): Promise<string>;
  getsetAsync(key: string, value: string, callback: function): Promise<string>;
  incrAsync(key: string, callback: function): Promise<number>;
  incrbyAsync(key: string, amount: number, callback: function): Promise<number>;
  incrbyfloatAsync(key: string, amount: number, callback: function): Promise<number>;
  mgetAsync(...keys: string, callback: function): Promise<string[]>;
  msetAsync(...params: string, callback: function): Promise<number>;
  msetnxAsync(...params: string, callback: function): Promise<number>;
  psetexAsync(key: string, pttl: number, value: string, callback: function): Promise<string>;
  setAsync(key: string, value: string, ...params: any, callback: function): Promise<string>;
  setbitAsync(key: string, offset: number, value: number, callback: function): Promise<number>;
  setexAsync(key: string, ttl: number, value: string, callback: function): Promise<number>;
  setnxAsync(key: string, value: string, callback: function): Promise<number>;
  setrangeAsync(key: string, offset: number, value: string, callback: function): Promise<number>;
  strlenAsync(key: string, callback: function): Promise<number>;
  discardAsync(callback: function, silent: boolean): Promise<string>;
  execAsync(callback: function): Promise<string>;
  multiAsync(callback: function): Promise<string>;
  unwatchAsync(callback: function): Promise<void>;
  watchAsync(callback: function): Promise<void>;

  // UPPER
  CREATECLIENT = this.createClient;
  QUIT = this.quit;
  END = this.end;
  AUTH = this.auth;
  ECHO = this.echo;
  PING = this.ping;
  SWAPDB = this.swapdb;
  SELECT = this.select;
  CLUSTER = this.cluster;
  READONLY = this.readonly;
  READWRITE = this.readwrite;
  GEOADD = this.geoadd;
  GEODIST = this.geodist;
  GEOHASH = this.geohash;
  GEOPOS = this.geopos;
  GEORADIUS = this.georadius;
  GEORADIUSBYMEMBER = this.georadiusbymember;
  HDEL = this.hdel;
  HEXISTS = this.hexists;
  HGET = this.hget;
  HGETALL = this.hgetall;
  HINCRBY = this.hincrby;
  HINCRBYFLOAT = this.hincrbyfloat;
  HKEYS = this.hkeys;
  HLEN = this.hlen;
  HMGET = this.hmget;
  HMSET = this.hmset;
  HSCAN = this.hscan;
  HSET = this.hset;
  HSETNX = this.hsetnx;
  HSTRLEN = this.hstrlen;
  HVALS = this.hvals;
  PFADD = this.pfadd;
  PFCOUNT = this.pfcount;
  PFMERGE = this.pfmerge;
  DEL = this.del;
  DUMP = this.dump;
  EXISTS = this.exists;
  EXPIRE = this.expire;
  EXPIREAT = this.expireat;
  KEYS = this.keys;
  MIGRATE = this.migrate;
  MOVE = this.move;
  OBJECT = this.object;
  PERSIST = this.persist;
  PEXPIRE = this.pexpire;
  PEXPIREAT = this.pexpireat;
  PTTL = this.pttl;
  RANDOMKEY = this.randomkey;
  RENAME = this.rename;
  RENAMENX = this.renamenx;
  RESTORE = this.restore;
  SCAN = this.scan;
  SORT = this.sort;
  TOUCH = this.touch;
  TTL = this.ttl;
  TYPE = this.type;
  UNLINK = this.unlink;
  WAIT = this.wait;
  BLPOP = this.blpop;
  BEPOP = this.bepop;
  BEPOPLPUSH = this.bepoplpush;
  LINDEX = this.lindex;
  LINSERT = this.linsert;
  LLEN = this.llen;
  LPOP = this.lpop;
  LPUSH = this.lpush;
  LPUSHX = this.lpushx;
  LRANGE = this.lrange;
  LREM = this.lrem;
  LSET = this.lset;
  LTRIM = this.ltrim;
  RPOP = this.rpop;
  RPOPLPUSH = this.rpoplpush;
  RPUSH = this.rpush;
  RPUSHX = this.rpushx;
  PSUBSCRIBE = this.psubscribe;
  PUBSUB = this.pubsub;
  PUBLISH = this.publish;
  PUNSUBSCRIBE = this.punsubscribe;
  SUBSCRIBE = this.subscribe;
  UNSUBSCRIBE = this.unsubscribe;
  EVAL = this.eval;
  EVALSHA = this.evalsha;
  SCRIPT = this.script;
  BGREWRITEAOF = this.bgrewriteaof;
  BGSAVE = this.bgsave;
  CLIENT = this.client;
  COMMAND = this.command;
  CONFIG = this.config;
  DBSIZE = this.dbsize;
  DEBUG = this.debug;
  FLUSHALL = this.flushall;
  FLUSHDB = this.flushdb;
  INFO = this.info;
  LASTSAVE = this.lastsave;
  MONITOR = this.monitor;
  ROLE = this.role;
  SAVE = this.save;
  SHUTDOWN = this.shutdown;
  SLAVEOF = this.slaveof;
  SLOWLOG = this.slowlog;
  SYNC = this.sync;
  TIME = this.time;
  SADD = this.sadd;
  SCARD = this.scard;
  SDIFF = this.sdiff;
  SDIFFSTORE = this.sdiffstore;
  SINTER = this.sinter;
  SINTERSTORE = this.sinterstore;
  SISMEMBER = this.sismember;
  SMEMBERS = this.smembers;
  SMOVE = this.smove;
  SPOP = this.spop;
  SRANDMEMBER = this.srandmember;
  SREM = this.srem;
  SSCAN = this.sscan;
  SUNION = this.sunion;
  SUNIONSTORE = this.sunionstore;
  ZADD = this.zadd;
  ZCARD = this.zcard;
  ZCOUNT = this.zcount;
  ZINCRBY = this.zincrby;
  ZINTERSTORE = this.zinterstore;
  ZLEXCOUNT = this.zlexcount;
  ZRANGE = this.zrange;
  ZRANGEBYLEX = this.zrangebylex;
  ZRANGEBYSCORE = this.zrangebyscore;
  ZRANK = this.zrank;
  ZREM = this.zrem;
  ZREMRANGEBYLEX = this.zremrangebylex;
  ZREMRANGEBYRANK = this.zremrangebyrank;
  ZREMRANGEBYSCORE = this.zremrangebyscore;
  ZREVRANGE = this.zrevrange;
  ZREVRANGEBYLEX = this.zrevrangebylex;
  ZREVRANGEBYSCORE = this.zrevrangebyscore;
  ZREVRANK = this.zrevrank;
  ZSCORE = this.zscore;
  ZUNIONSTORE = this.zunionstore;
  ZSCAN = this.zscan;
  APPEND = this.append;
  BITCOUNT = this.bitcount;
  BITFIELD = this.bitfield;
  BITOP = this.bitop;
  BITPOS = this.bitpos;
  DECR = this.decr;
  DECRBY = this.decrby;
  GET = this.get;
  GETBIT = this.getbit;
  GETRANGE = this.getrange;
  GETSET = this.getset;
  INCR = this.incr;
  INCRBY = this.incrby;
  INCRBYFLOAT = this.incrbyfloat;
  MGET = this.mget;
  MSET = this.mset;
  MSETNX = this.msetnx;
  PSETEX = this.psetex;
  SET = this.set;
  SETBIT = this.setbit;
  SETEX = this.setex;
  SETNX = this.setnx;
  SETRANGE = this.setrange;
  STRLEN = this.strlen;
  DISCARD = this.discard;
  EXEC = this.exec;
  MULTI = this.multi;
  UNWATCH = this.unwatch;
  WATCH = this.watch;
};



declare const obj = MemoryCache;
export default obj;